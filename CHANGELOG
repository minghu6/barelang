


【回到现在知道的东西，做一个demo语言】
于是有了bas

【通过增加一门连通上下的内部使用的中间语言】
作为一门编译型的语言，或者没有运行时的语言，或者对我们写的这个东西来说，提供的是从高级代码到低级代码的翻译工作而不是实时运行
的这么一门语言，如果上层是函数式的，那么如果要提供编译型语言特有的指针和因此的内存随机访问的能力，来取代在某些任务上在cpu时间或内存上过于低效的代码部分。
从元编程能力的角度，函数式风格的语言使用宏，不同时期展开的宏，嵌入在编译过程的宏和预处理的宏，而更加面向底层的语言则使用指针，指针不仅提供了内存随机访问的能力
更主要是非常强大的面向硬件风格的元编程手段，一个指针参数可以包含任意信息！

所以如果使用一门内部的中间语言，暴露出指针的机制，那么就可以结合这两种元编程方法的优势。这是`bacore`部分的尝试的原因。

但是首先，作为上层语言的实现准备，看了很长时间的Clojure的持久化数据结构，主要是支持等效O(1)复杂度的持久化向量的实现--32分支的Trie，然后是有人在C上实现的
该Trie的拓展来支持额外的slice和expand操作。

然后在写bacore过程中被，本来设想的无语法结构的Lisp和实际上的有一定语法结构的Lisp混在一起，在列表里找不到恰当放置指针语法的方式令人难受，而本质问题是真根本不是个人
能承担得起的工作！大量工作面临的是从0开始的境地，这令人沮丧，因此放弃了这个设计。


【一门简单的语言】
没有特别的想法, 想做一个简洁(写起来省事儿), 自恰(函数式, 修补Haskell一些缺乏群继承关系的历史包袱), 不惜牺牲一定的泛用性
函数可以通过`.`来链接, 大部分意义上是一个简化的没有历史包袱的Haskell.
